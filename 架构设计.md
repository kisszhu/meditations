## 设计原则

> - [x] 主要组件的责任是否得到了良好定义？是否恰当？
> - [x] 主要组件间的协作是否得到了良好定义？
> - [x] 耦合是否得以最小化？
> - [x] 你能否确定重复的潜在来源？
> - [x] 接口定义和各项约束是否可接受？
> - [x] 每个模块在执行过程中是否能访问到其所需的数据？是否能在需要时进行访问？

### SRP

Single Responseble Principle 即单一职责原则

### 高内聚、低耦合

将应用划分为在功能上尽可能不重复的功能点。主要的参考因素就是最小化交互、高内聚、低耦合

### 最小知识原则

一个组件或者对象不应该知道其他组件或者对象的内部实现细节

### 最小化预先设计

只设计必须的内容。在一些情况，你可能需要预先设计一些内容。另外一些情况，尤其对于敏捷开发，你可以避免设计过度。如果你的应用需求是不清晰的，最好不要做大量的预先设计

### TDD

**TDD**

测试驱动开发（Test Driven Development）

**BDD**

行为驱动开发（Behavior Driven Development）

**ATDD**

验收测试驱动开发（Acceptance Test Driven Development）

通过单元测试用例来驱动功能代码的实现，团队需要定义出期望的质量标准和验收细则，以明确而且达成共识的验收测试计划（包含一系列测试场景）来驱动开发人员的TDD实践和测试人员的测试脚本开发。面向开发人员，强调如何实现系统以及如何检验

**DDD**

领域驱动开发（Domain Drive Design）

DDD指的是Domain Drive Design，也就是领域驱动开发，DDD实际上也是建立在这个基础之上，因为它关注的是Service层的设计，着重于业务的实现，将分析和设计结合起来，不再使他们处于分裂的状态，这对于我们正确完整的实现客户的需求，以及建立一个具有业务伸缩性的模型

#### 核心

**TDD核心**

- 需求：
  1. 分析业务需求
  2. 梳理业务流程
  3. 定义业务边界
  4. 业务功能分解、分级
  5. 异常流
  6. 输出测试用例
- 红：在编写测试方法时，应遵循Given-When-Then模式，这种方式描述了测试的准备，期待的行为，以及相关的验收条件
  1. 编写Given时，"驱动"我们思考被测对象的创建，以及它与其他对象的协作
  2. 编写When时，"驱动"我们思考被测接口的方法命名，以及它需要接收的传入参数；返回参数；函数计算逻辑
  3. 编写Then时，"驱动"我们分析被测接口的返回值，异常逻辑校验
- 绿：通过算法实现需求
- 重构：优化代码和测试

**TDD三大定律**

该定律由Robert Martin提出：

- 没有测试之前不要写任何功能代码
- 只编写恰好能够体现一个失败情况的测试代码
- 只编写恰好能通过测试的功能代码

**FIRST原则**

- Fast：测试要非常快，每秒能执行几百或几千个
- Isolated：测试应能够清楚的隔离一个失败
- Repeatable：测试应可重复运行，且每次都以同样的方式成功或失败
- Self-verifying：测试要无歧义的表达成功或失败
- Timely：频繁、小规模的修改代码

#### 实践

**step1:需求分析**

在开始TDD之前，我们应该进行需求的梳理，整理出一份验收表格，即测试用例（包括：正确的输入、正确的输出、异常的输入、异常的输出等）。当有了这样一份测试用例，我们的代码要实现的目标更明确，提高代码的质量

**step2:红**

有了第一步需求分析形成的测试用例，就可以开始第二步测试代码的编写。值得注意的是单元测试不能针对方法编写测试，而应根据业务编写测试用例。一个测试方法只能做一件事情，代表一个测试样本和一个业务规则

------

测试代码要尽可能的简单：

单元测试一般采用3A模式（Arrange、Act、Assert）。代码量不宜太多，单元测试本身也是代码，测试代码本身不会再被验证是否正确。因此测试代码越是简单，就越容易判断测试代码是否正确。否则一旦执行的时候，当测试条变为红色的时候，不好排查是测试代码有问题，还是被测试代码有问题。增加了排查难度

------

测试代码需要考虑以下几个点：

- 被测试的类名是什么（这个时候就需要考虑类的职责问题了）
- 被测试的API的名字，参数和返回值（这个时候考虑的是功能点的设计和API的易测性）
- 最容易编写的测试代码是调用一个API，然后通过API的返回值，调用Assert进行验证。所以被测试的API在设计的过程中，最好要符合幂等性。

这里主要还是强调类API的设计，而非具体的代码实现。

------

测试代码需要多久写完：

- TDD里的测试代码不一定是一口气写完的。有些会根据后续的算法和重构，进行相应的修改
- 一般TDD里的一个循环（红 -> 绿 -> 重构）的周期不要太长，一个小时为一个周期会合适些。
- 如果单元测试代码需要写很久，要有非常多的前置条件满足，才能测试对应的API。或者在验证结果的正确性时，需要很多代码才有办法验证（比如要获得某个全局变量才能验证等等）这个时候我们需要考虑：我们的测试力度是否太大了（是否变成了集成测试），或者我们的API设计的太复杂了，不符合幂等性

综上所述，单元测试代码越简单，也会让程序员愿意往下接着按TDD的方式写代码。否则容易出现的一个现象就是：**放弃**

**step3:绿**

一个TDD的周期不宜太长。不管是红、绿还是重构。每个步骤的步伐小一些会更可控、出现问题定位也更快。

实现算法：

绿的环节中，重要是快速、小步快跑实现功能代码。这个时候代码质量不是首要考虑的事情。所以这个阶段往往会出现一些临时代码，或者写死常量等。这些问题都会在重构的环节中消灭掉。目的只有一个就是：**快**。

坚持小步快跑，我们能得到更多

**step4:重构**

TDD中"绿"是分成若干个小阶段来实现的，而不是一口气实现"绿"的过程。那么我们为什么要把"绿"分布在若干个小阶段来实现呢。最主要的原因是为了重构

------

重构的作用：

“重构”在这一个过程中起到了压舱石的作用。没有经历过重构的代码，一般代码的质量都是一般的，可维护性和可扩展性是较差的。但是相对于一般软件的集中式重构，分阶段重构，小步快跑方式的重构有以下几个优点：

- 重构紧挨着“绿”的过程，有测试代码保驾护航，重构更有信心
- 每次重构耗时不长，大脑不需要处理非常多的信息，有利于集中注意力，也让重构的质量更有保证
- 经常的重构，让大脑不停思考什么是好的代码， 如何实现好的代码有更深的感悟。时间一长，这些思考的累积，让自身对于编程的感悟更多，同时对于优质的代码有更深刻的认知，有利于写出更优秀的代码

------

TDD的收获：

经过不停的迭代三步曲的过程，我们有了如下收获：

- 获得了测试用例，后续的接手人，也更方便对接业务
- 获得了单元测试代码，日后的代码维护更清楚
- 实现了业务逻辑，提高了边界的测试，提高了业务逻辑的质量
- 通过“重构”，获得了质量越来越好的代码

在这一TDD过程中， 每个环节都很重要，缺一不可。和别人不同的是，我会更看重“重构”这一容易被忽视的过程。因为有了这一环节的存在，迫使我把三步曲的实施时间尽可能的小。让我对代码的把控更游刃有余，同时也让我不停的思考代码的价值和质量

### DRY

在《程序员修炼之道》中，Dave Thomas和Andy Hunt称之为DRY原则（Don't Repeat Yourself，别重复自己）

**重复是怎样发生的：**

我们所见到的大多数重复都可归入下列范畴：

- 强加的重复（imposed duplication）
- 无意的重复（inadvertent duplication）
- 无耐性的重复（impatient duplication）
- 开发者之间的重复（inter developer duplication）

**无意的重复：**

```java
class Line{
    public:
    	Point start;
    	Point end;
    	double length;
}
```

第一眼看上去，这个类似乎是合理的。线段显然有起点和终点，并总是有长度。但这里有重复。长度是由起点和终点决定的：改变其中一个，长度就会变化。最好是让长度称为计算字段：

```java
class Line{
    public ：
      Point start;
    	Point end;
    	double length(){return start.distinceTo(end);}
}
```

在以后的开发过程中，你可能因为性能原因而选择违反DRY原则。这经常会发生在你需要缓存数据，比避免重复昂贵的操作时。其诀窍是使影响局部化。对DRY原则的违反没有暴露给外界：只有类中的方法需要注意"保持行为良好"

```java
class Line{
    private: 
    	bool changed;
    	double length;
    	Point start;
    	Point end;
    public :
    	void setStart(Point p){start = p; changed = true;}
    	void setEnd(Point p){end = p; changed = true;}
    	Point getStart(void){return start;}
    	Point getEnd(void){return end;}
    	double getLength(){
            if(changed){
                length = start.distinceTo(end);
                changed = false;
            }
            return length;
    	}      
}
```

每次看到重复代码，都代表遗漏了抽象。重复的代码可能成为子程序或干脆是另一个类。将重复代码叠放进类似的抽象，增加了你的设计语言的词汇量。其他程序员可以用到你创建的抽象设施。编码变得越来越快，错误越来越少，因为你提升了抽象层级

重复最明显的形态是你不断看到明显一样的代码，就像是某位程序员疯狂地用鼠标不断复制粘贴代码。可以用单一方法来替代之

较隐蔽的形态是在不同模块中不断重复出现，检测同一组条件的switch/else或if/else链。可以用多态来替代之。

更隐蔽的形态是采用类似算法但具体代码行不同的模块。这也是一种重复，可以使用模板方法或策略模式来修正。

### 正交性

> 高内聚、低耦合
>
> 最小知识原则

我们想要设计自足（self-contained）的组件：独立，具有单一、良好定义的目的。如果组件是相互隔离的，你就知道你能够改变其中之一，而不用担心其余组件。只要你不改变组件的外部接口，你就可以放心：你不会造成波及整个系统的问题

谈一个不是特别恰当的比方，在项目的开发中，我会比较反感一条流程一路跑到黑这种，更喜欢存在一个个公交枢纽，可以在适当的节点上规避风险，防止雪崩

如果你编写正交的系统，你得到两个主要的好处：提高生产率和降低风险

**提高生产率：**

- 改动得以局部化，所以开发时间和测试时间得以降低。与编写单个的大块代码相比，编写多个相对较小的、自足的组件更为容易。你可以设计、编写简单的组件，对其进行单元测试。当你增加新代码时，无须不断改动已有的代码
- 正交的途径还能够促进复用。如果组件具有明确而具体的、良好定义的责任，就可以用其最初的实现者未曾想象过的方式，把它们与新组件组合在一起
- 如果你对正交的组件进行组合，生产率会有相当微妙的提高。假定某个组件做M件事情，而另一个组件做N件事情。如果它们是正交的，而你把它们组合在一起，结果就能做M*N件事情。但是，如果这两个组件是非正交的，它们就会重叠，结果能做的事情就更少。通过组合正交的组件，你的每一份努力都能得到更多的功能

**降低风险：**

- 正交的途径能降低任何开发中固有的风险
- 有问题的代码区域被隔离开来。如果某个模块有毛病，它不太可能把病症扩散到系统的其余部分。要把它切掉，换成健康的新模块也容易
- 所得系统更健壮。对特定区域做出小的改动与修正，你所导致的任何问题都将局限在该区域中
- 正交系统很可能得到更好的测试，因为设计测试、并针对其组件运行测试更容易
- 你不会与特定的供应商、产品、或是平台紧绑在一起，因为与这些第三方组件的接口将隔离在全部开发的较小部分中

**工具箱&库：**

如果它要求你以一种特殊的方式创建或访问对象，那么它就不是正交的。这样的细节与代码隔离具有额外的好处：它使得你在以后更容易更换供应商（类似Log4j）、切面编程

**编码：**

每次你编写代码，都有降低应用正交性的风险。除非你不仅时刻监视你正在做的事情，也时刻监视应用的更大语境，否则，你就有可能无意中重复其他模块的功能，或是两次表示已有的知识

- **让你的代码保存解耦**。编写"羞怯"的代码——也就是不会没有必要地向其他模块暴露任何事情、也不依赖其他模块的实现的模块。试一试"解耦与得墨忒耳法则"中讨论的得墨忒耳法则。如果你需要改变对象的状态，让这个对象替你去做。这样，你的代码就会保存与其他代码的实现的隔离，并增加你保持正交性的机会
- **避免使用全局数据**。每当你的代码引用全局数据时，它都把自己与共享该数据的其他组件绑在了一起。即使你只想对全局数据进行读取，也可能会带来麻烦（例如，如果你突然需要把代码改为多线程的）。一般而言，如果你把所需的任何语境（context）显式地传入模块，你的代码就会更易于理解和维护。在面向对象应用中，语境常常作为参数传给对象的构造器，换句话说，你可以创建含有语境的结构，并传递指向这些结构的引用
- **避免编写相似的函数**

**测试：**

正交地设计和实现的系统也更易于测试

构建单元测试本身是对正交性的一项有趣测试。要构建和链接某个单元测试，都需要什么？只是为了编译或链接某个测试，你是否就必须把系统其余的很大一部分拽进来？如果是这样，你已经发现了一个没有很好地解除与系统其余部分耦合的模块

修正bug也是评估整个系统的正交性的好时候。当你遇到问题时，评估修正的局部化程度

你是否只改动了一个模块，或者改动分散在整个系统的各个地方？当你做出改动时，它修正了所有问题，还是又神秘地出现了其他问题？这是开始运用自动化的好机会。可以分析每个bug修正所影响的源文件数目的变化趋势

### 可撤销性

错误在于假定决策是浇筑在石头上的，同时还在于没有为可能出现的意外事件做准备。要把决策视为是写在沙滩上的，而不要把它们刻在石头上。大浪随时可能到来，把它们抹去

通常，你可以把第三方产品隐藏在定义良好的抽象接口后面。事实上，在我们做过的任何项目中，我们都总能够这么做。但假定你无法那么彻底地隔离它，如果你必须大量地把某些语句分散在整个代码中，该怎么办？把该需求放入元数据，并且使用某种自动机制——比如Aspect或Perl——把必须的语句插入代码自身中。无论你使用的是何种机制，让它可撤销。如果某样东西是自动添加的，它也可以被自动去掉

### 按合约设计

Bertrand Meyer[Mey97b]为Eiffel语言发展了按合约设计的概念。这是一种简单而强大的技术，它关注的是用文档记载（并约定）软件模块的权力和责任，以确保程序正确性。什么是正确性？不多不少，做它声明要做的事情的程序。用文档记载这样的声明，并进行校验，是按合约设计（简称DBC）的核心所在

```java
/**
 * @pre f != null
 * @post getFont() == f
 */
public void setFront(final font f){
    //.....
}
```

使用DBC的最大好处也许是它迫使需求与保证的问题走到前台来。在设计时简单地列举输入域的范围是什么、边界是什么、例程允许交付什么——或者，更重要的是，它不允诺交付什么——是向着编写更好的软件的一次飞跃。不对这些事情作出陈述，你就回到了靠巧合编程

如果语言不在代码中支持DBC，你也许就只能走这么远了——这并不太坏。毕竟，DBC是一种设计技术。即使没有自动检查，你也可以把合约作为注释放在代码中，并仍然能够得到非常实际的好处。至少，在遇到麻烦时，用注释表示的合约给了你一个着手的地方

**断言：**

对于Java，可以使用IContract。它读取（JavaDoc形式的）注释，生成新的包含了断言逻辑的源文件

**DBC与早崩溃：*

DBC相当符合我们关于早崩溃的概念。假定你有一个计算平方根的方法。它需要一个前提条件，把参数域限制为正数。Eiffel的前条件通过关键字require声明，后条件通过ensure声明，所以你可以编写：

```eiffel
sqrt：DOUBLE is
		-- Square root routine
	require
		sqrt_arg_must_be_positive: Current >=0
	--- ...
    --- calculate square root here
    --- ...
    ensure
    	((Result*Result)-Current).abs <= epsilon*Current.abs;
    	-- Result should be within error tolerance
    end;	
```

谁负责检查前条件，是调用者，还是被调用的例程？如果作为语言的一部分实现，答案是两者都不是：前条件是在调用者调用例程之后，但在进入例程自身之前，在幕后测试的。因为如果要对参数进行任何显式的检查，就必须由调用者来完成，因为例程自身永远也不会看到违反了其前条件的参数。（对于没有内建支持的语言，你需要用检查这些断言的"前言"（preamble）和/或"后文"（postamble）把被调用的例程括起来）

通过早崩溃、在问题现场找到和诊断问题要容易很多

按合约设计在我看来并没有流行起来，我觉得可能是两点原因，第一点是主流语言并没有支持合约设计语法，第二点是让需求走到前台完全可以通过TDD来保证

### 解耦与得墨忒耳法则

**使耦合减至最少：**

```java
public void plotDate(Date aDate,Selection aSelection){
    TimeZone tz = aSelection.getRecorder().getLocation().getTimeZone();
}
```

Selection、Recorder及Location这个编码风格极大地增加了我们的类所依赖的类的数目。这为何是一件坏事？因为它增加了系统别的地方的一个无关改动影响你的代码的风险。例如，如果Fred对Location做出改动，使它不在直接包含TimeZone，你也必须改动你的代码

应该直接要求提供你所需的东西，而不是自行"挖通"调用层次：

```java
public void plotDate(Data aDate, TimeZone aTz){
    ...
}
plotDate(someDate,someSelection.getTimeZone());
```

我们给Selection增加了一个方法，让其替我们获取时区：调用者不关心时区是直接来自Recorder，还是来自Recorder中包含的某个对象

对象间直接的横贯关系有可能很快带来依赖关系的组合爆炸

**函数的得墨忒耳法则：**

函数的得墨忒耳法则规定，某个对象的任何方法都应该只调用属于以下情形的方法：

```java
class Demeter{
    private: 
    	A *a;
    	int func();
    public:
    	//...
    	void example(B& b);
    
    void Demeter::example(B& b){
        C c;
        int f = func();  // 它自身
        b.invert();      // 传入该方法的任何参数
        a = new A();
        a->setActive();  // 它创建的任何对象
        c.print();       // 任何直接持有的组件对象
    }
}
```

**对象的得墨忒耳法则**

对象的得墨忒耳法则规定，对象的属性和状态，只能由这个对象自身来修改

### 元程序设计

细节会弄乱我们整洁的代码——特别是如果它们经常变化。每当我们必须去改动代码，以适应商业逻辑、法律或管理人员个人一时的口味的某种变化时，我们都有破坏系统或引入新的bug的危险

所以我们说"把细节赶出去"把它们赶出代码。当我们在与它斗争时，我们可以让我们的代码变得高度可配置和"软和"——也就是，容易适应变化

**动态配置：**

> 要配置，不要集成

首先，我们想要让我们的系统变得高度可配置。不仅是像屏幕颜色和提示文本这样的事物，而且也包括诸如算法、数据库产品、中间件技术和用户界面风格之类更深层面的选择。这些选择应该作为配置选项，而不是通过集成或工程实现

**元数据驱动的应用：**

> 将抽象放进代码，细节放进元数据

但我们不只是想把元数据用于简单的偏好。我们想要尽可能多地通过元数据配置和驱动引用。我们的目标是以声明方式思考（规定要做什么，而不是怎么做），并创建高度灵活和可适应的程序。我们通过采用一条一般准则来做到这一点：`为一般情况编写程序，把具体情况放在别处——在编译的代码库之外`

- 它迫使你解除你的设计的耦合，从而带来更灵活、可适应性更好的程序
- 它迫使你推迟细节处理，创建更健壮、更抽象的设计——完全推迟到程序之外
- 无需重新编译应用，你就可以对其进行定制。你还可以利用这一层面的定制，轻松地绕开正在运行的产品系统中的重大bug
- 与通用的编程语言的情况相比，可以通过一种大为接近问题领域的方式表示元数据（领域语言）
- 你甚至还可以用相同的应用引擎——但是用不同的元数据——实现若干不同的项目

我们想要推迟大多数细节的定义，直至最后时刻，并且尽可能让细节保存"软和"——尽可能易于改动。通过精心制作允许我们快速作出变更的解决方案，我们将能够更好地应对使许多项目覆灭的"转向"

商业逻辑：

也许你在编写一个具有可怕的工作流需要的系统。动作会根据复杂的（和变化的）商业规则启动和停止。考虑在某种基于规则的系统（即专家系统）中对它们进行编码，并嵌入到你的应用中。这样，你将通过编写规则、而不是修改代码来配置它

如何进行配置：

纯文本的威力，运行时重新加载

**不要编写渡渡鸟代码：**

没有元数据，你的代码就不可能获得它应有的适应性和灵活性。这是一件坏事吗？嗯，在外面的现实世界里，不能适应的物种就会灭亡。毛里求斯岛上的渡渡鸟不能适应人类和他们的家畜的出现，很久就灭绝了。这是人类记录的第一起物种的灭绝

不要让你的项目（或你的职业生涯）走上渡渡鸟的道路

### 明显的行为未被实现

遵循“最小惊异原则”（The Principle of Least Surprise），函数或类应该实现其他程序员有理由期待的行为。例如，考虑一个将日期名称翻译为表示该日期的枚举的函数

```java
Day day = DayDate.StringToDay(String dayName);
```

我们期望字符串Monday翻译为Day.MONDAY。我们也期望常用缩写形式也能被翻译出来，我们还期望函数忽略大小写

如果明显的行为未被实现，读者和用户就不能在依靠他们对函数名称的直接。他们不再信任原作者，不得不阅读代码细节
