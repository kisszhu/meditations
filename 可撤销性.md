## 可撤销性

**BackGround**

```
注意: 通过一个小故事来描述，故事的合理性不用细究
主人公: 梅陇（后端架构师）、余生（前端架构师）、木小金（产品经理）

故事开始: 
在我们的OA项目中，需要用到工作流，最后选择使用activity工作流。但是我们的用法存在一些问题，我们把工作流中涉及到的一些业务信息也都一并存储到了activity中，下面来看看我们遇到的问题。
```

**工作流** **&** **业务系统的集成**

在工作流与业务系统的集成解决方案中，我们流程节点中的一些具体业务相关的数据也都一并存储到工作流中，当初这样做的好处是因为，在业务系统中不用建立大量流程节点涉及到的业务信息表，而是把这些业务信息转化为K-V结构作为工作流节点的属性存储到了activity中。

但是，随着时间的过度，慢慢发现工作流占据了系统70%以上的业务，导致大量的业务数据都存储在了工作流引擎中，不光基于K-V的查询效率变慢，也导致了一个严重的问题，就是业务系统和工作流引擎的边界出现了问题。理论上工作流引擎应该是辅助业务系统的，但是慢慢的变成工作流把业务系统架空了。

系统边界的设定出现问题，则未来必定伴随着大量的耦合，不利于未来业务功能的扩展。所以我们及时的停止了这一解决方案，在解决方案回滚的过程中，则又加深了可撤销性的理解。

**可撤销性**

可撤销性决定了，当决策发生变化时，伴随着改动成本的大小。

通常错误在于假定决策是浇筑在石头上的，同时还在于没有为可能出现的意外事件做准备。要把决策视为是写在沙滩上的，而不要把它们刻在石头上。大浪随时可能到来，把它们抹去。

通常，你可以把第三方产品隐藏在定义良好的抽象接口后面。事实上，在我们做过的任何项目中，我们都总能够这么做。但假定你无法那么彻底地隔离它，如果你必须大量地把某些语句分散在整个代码中，该怎么办？把该需求放入元数据，并且使用某种自动机制——比如Aspect或Perl——把必须的语句插入代码自身中。无论你使用的是何种机制，让它可撤销。如果某样东西是自动添加的，它也可以被自动去掉。

**总结**

在项目开发中，不要存在金科玉律，时刻考虑可撤销性，挖的坑，不要把自己埋进去。
